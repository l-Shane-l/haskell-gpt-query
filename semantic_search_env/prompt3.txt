I have the following haskell code, it was suppose to print to the console but it just is not. 

can you instead implement reflex Dynamic with text and put this in a widget and have the text update with logs from the events firing

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.Maybe (fromMaybe)
import qualified GHCJS.DOM.DataTransfer as DOM
import qualified GHCJS.DOM.Element as DOM
import qualified GHCJS.DOM.EventM as DOM
import qualified GHCJS.DOM.GlobalEventHandlers as DOM
import qualified GHCJS.DOM.HTMLElement as DOM
import qualified GHCJS.DOM.MouseEvent as DOM
import qualified GHCJS.DOM.Types as DOM (uncheckedCastTo)
import Language.Javascript.JSaddle
import Reflex.Dom

main :: IO ()
main = mainWidget app

app :: (DomBuilder t m, Prerender t m, MonadIO (Performable m)) => m ()
app = do
  -- Set up two draggable items
  prerender_ blank $ do
    draggable item1 "a picture"
    draggable item2 "some code"
  -- Set up the drop zone and handle drag events
  out <- handleDragEvents
  return ()

-- Define the first draggable item (an image)
item1 :: DomBuilder t m => m (Element EventResult (DomBuilderSpace m) t, ())
item1 = elAttr' "div" ("draggable" =: "true") $ text "This is a draggable div"

-- Define the second draggable item (a code snippet)
item2 :: DomBuilder t m => m (Element EventResult (DomBuilderSpace m) t, ())
item2 =
  elAttr'
    "pre"
    ( "draggable" =: "true"
        <> "style" =: "-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none;"
    )
    $ text "main = putStrLn \"Hello world!\""

-- Function to make an element draggable and attach data to it
draggable ::
  ( DomBuilderSpace m ~ GhcjsDomSpace,
    TriggerEvent t m,
    MonadJSM m,
    PerformEvent t m,
    MonadIO (Performable m)
  ) =>
  m (Element EventResult (DomBuilderSpace m) t, ()) ->
  String ->
  m ()
draggable elmnt attachment = do
  dragsite <- fst <$> elmnt
  dragStartEvent <- wrapDomEvent
    (DOM.uncheckedCastTo DOM.HTMLElement $ _element_raw dragsite)
    (`DOM.on` DOM.dragStart)
    $ do
      dt <-
        fromMaybe (error "no dt?")
          <$> (DOM.getDataTransfer =<< DOM.event)
      liftIO $ putStrLn "Drag start event triggered"
      DOM.setEffectAllowed dt ("all" :: JSString)
      DOM.setDropEffect dt ("move" :: JSString)
      DOM.setData
        dt
        ("application/x-reflex-description" :: JSString)
        attachment
  performEvent_ $ liftIO (putStrLn "Drag started") <$ dragStartEvent
  return ()

-- Function to handle drag events in the drop zone
handleDragEvents ::
  ( DomBuilder t m,
    Prerender t m,
    MonadIO (Performable m)
  ) =>
  m ()
handleDragEvents = prerender_ (return ()) $ do
  let ddEvent ::
        (DOM.DataTransfer -> DOM.EventM e DOM.MouseEvent a) ->
        DOM.EventM e DOM.MouseEvent a
      ddEvent op = do
        dt <-
          fromMaybe (error "no DT?")
            <$> (DOM.getDataTransfer =<< DOM.event)
        op dt
      ddEvent_ ::
        DOM.EventM e DOM.MouseEvent () ->
        DOM.EventM e DOM.MouseEvent ()
      ddEvent_ op = ddEvent (const op)

  rec -- Handle drag enter event to indicate the drop zone is active
      dragEnterEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragEnter)
          (ddEvent_ DOM.preventDefault)
      performEvent_ $ liftIO (putStrLn "Drag enter") <$ dragEnterEvent

      -- Handle drag leave event to revert the drop zone style
      dragLeaveEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragLeave)
          (ddEvent_ $ return ())
      performEvent_ $ liftIO (putStrLn "Drag leave") <$ dragLeaveEvent

      -- Define the drop zone
      dropsite <- fst <$> elDynAttr' "div" dropsiteAttrs (dynText dropText)
      let dsHTMLel = DOM.uncheckedCastTo DOM.HTMLElement $ _element_raw dropsite
      inDrop <-
        holdDyn False $
          leftmost
            [ True <$ dragEnterEvent,
              False <$ dragLeaveEvent,
              False <$ dropEvent
            ]
      dropsiteAttrs <- return . ffor inDrop $ \case
        True -> "style" =: "border:1em solid blue;padding:2em;margin:2em;background-color:green;"
        False -> "style" =: "border:1em solid blue;padding:2em;margin:2em;"

      -- Handle drag over event to allow dropping
      dragOverEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragOver)
          (ddEvent_ DOM.preventDefault)
      performEvent_ $ liftIO (putStrLn "Drag over") <$ dragOverEvent

      -- Handle drop event to capture dropped data
      dropEvent <- wrapDomEvent dsHTMLel (`DOM.on` DOM.drop) $
        ddEvent $ \dt -> do
          DOM.preventDefault
          liftIO $ putStrLn "Drop event triggered"
          DOM.getData dt ("application/x-reflex-description" :: String)
      performEvent_ $ liftIO (putStrLn "Dropped") <$ dropEvent

      dropText <- holdDyn "Drop here" $ fmap ("Dropped " <>) dropEvent
  return ()
