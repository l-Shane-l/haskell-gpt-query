Can you please add basic event logging to the browser console to the following code.

Keep it simple like liftIO putStrLn "test"

Or some lifting

DO NOT try to use JS directly or any other JS approach do it with reflex or my lifting into context

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

module Main where

import Data.Maybe (fromMaybe)
import qualified GHCJS.DOM.DataTransfer as DOM
import qualified GHCJS.DOM.Element as DOM
import qualified GHCJS.DOM.EventM as DOM
import qualified GHCJS.DOM.GlobalEventHandlers as DOM
import qualified GHCJS.DOM.HTMLElement as DOM
import qualified GHCJS.DOM.MouseEvent as DOM
import qualified GHCJS.DOM.Types as DOM (uncheckedCastTo)
import Language.Javascript.JSaddle
import Reflex.Dom

main :: IO ()
main = mainWidget app

app :: (DomBuilder t m, Prerender t m) => m ()
app = do
  -- Set up two draggable items
  prerender_ blank $ do
    draggable item1 "a picture"
    draggable item2 "some code"
  -- Set up the drop zone and handle drag events
  handleDrrgEvents
  return ()

-- Define the first draggable item (an image)
item1 :: DomBuilder t m => m (Element EventResult (DomBuilderSpace m) t, ())
item1 = elAttr' "div" ("draggable" =: "true") $ text "This is a draggable div"

-- Define the second draggable item (a code snippet)
item2 :: DomBuilder t m => m (Element EventResult (DomBuilderSpace m) t, ())
item2 =
  elAttr'
    "pre"
    ( "draggable" =: "true"
        <> "style" =: "-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none;"
    )
    $ text "main = putStrLn \"Hello world!\""

-- Function to make an element draggable and attach data to it
draggable ::
  ( DomBuilderSpace m ~ GhcjsDomSpace,
    TriggerEvent t m,
    MonadJSM m,
    PerformEvent t m
  ) =>
  m (Element EventResult (DomBuilderSpace m) t, ()) ->
  String ->
  m ()
draggable elmnt attachment = do
  dragsite <- fst <$> elmnt
  dragStartEvent <- wrapDomEvent
    (DOM.uncheckedCastTo DOM.HTMLElement $ _element_raw dragsite)
    (`DOM.on` DOM.dragStart)
    $ do
      dt <-
        fromMaybe (error "no dt?")
          <$> (DOM.getDataTransfer =<< DOM.event)
      DOM.setEffectAllowed dt ("all" :: JSString)
      DOM.setDropEffect dt ("move" :: JSString)
      DOM.setData
        dt
        ("application/x-reflex-description" :: JSString)
        attachment
  performEvent_ $ return () <$ dragStartEvent
  return ()

-- Function to handle drag events in the drop zone
handleDragEvents ::
  ( DomBuilder t m,
    Prerender t m
  ) =>
  m ()
handleDragEvents = prerender_ (return ()) $ do
  let ddEvent ::
        (DOM.DataTransfer -> DOM.EventM e DOM.MouseEvent a) ->
        DOM.EventM e DOM.MouseEvent a
      ddEvent op = do
        dt <-
          fromMaybe (error "no DT?")
            <$> (DOM.getDataTransfer =<< DOM.event)
        op dt
      ddEvent_ ::
        DOM.EventM e DOM.MouseEvent () ->
        DOM.EventM e DOM.MouseEvent ()
      ddEvent_ op = ddEvent (const op)

  rec -- Handle drag enter event to indicate the drop zone is active
      dragEnterEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragEnter)
          (ddEvent_ DOM.preventDefault)
      -- Handle drag leave event to revert the drop zone style
      dragLeaveEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragLeave)
          (ddEvent_ $ return ())
      -- Define the drop zone
      dropsite <- fst <$> elDynAttr' "div" dropsiteAttrs (dynText dropText)
      let dsHTMLel = DOM.uncheckedCastTo DOM.HTMLElement $ _element_raw dropsite
      inDrop <-
        holdDyn False $
          leftmost
            [ True <$ dragEnterEvent,
              False <$ dragLeaveEvent,
              False <$ dropEvent
            ]
      dropsiteAttrs <- return . ffor inDrop $ \case
        True -> "style" =: "border:1em solid blue;padding:2em;margin:2em;background-color:green;"
        False -> "style" =: "border:1em solid blue;padding:2em;margin:2em;"
      -- Handle drag over event to allow dropping
      dragOverEvent <-
        wrapDomEvent
          dsHTMLel
          (`DOM.on` DOM.dragOver)
          (ddEvent_ DOM.preventDefault)
      performEvent_ $ return () <$ dragOverEvent

      -- Handle drop event to capture dropped data
      dropEvent <- wrapDomEvent dsHTMLel (`DOM.on` DOM.drop) $
        ddEvent $ \dt -> do
          DOM.preventDefault
          DOM.getData dt ("application/x-reflex-description" :: String)
      dropText <- holdDyn "Drop here" $ fmap ("Dropped " <>) dropEvent
  return ()
